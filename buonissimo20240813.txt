//CONFIGS
const express = require('express');
const router = express.Router();
const database = require('../db');
const credentials = require('./credentials');
// const app = express();


//SCHEMAS
const Member = require('../schema/members');
const Parent = require('../schema/parents');
const myClient = require('../schema/clients');
const Calender = require('../schema/calender');
const Entrance = require('../schema/registerEntrance');
const Plan = require('../schema/plans');
const Graduation = require('../schema/graduation');
const mailerGrau = require('./sendGrau');
const mailer = require('./sendMailer');
const restaurant = require('./contactRestaurant');
const Pay = require('../schema/payment');
const MemberCount = require('../schema/member_count');
const Finencepay = require('../schema/finencepays');
const Finence_category = require('../schema/finence_category');
const Expense = require('../schema/expenses');
const RestClient = require('../schema/rest_clients');
const RestMenu = require('../schema/restmenu');
const Historyorder = require('../schema/historyorder');
const Restadmin = require('../schema/restadmins');
const Costrest = require('../schema/costrests');
const Rest_maneger = require('../schema/rest_manegers')
const CloseCaixa = require('../schema/closecaixas');
const Costcategory = require('../schema/costCategory');
const Dakoku = require('../schema/dakoku');
const Iventory = require('../schema/inventorys');
const Suppliers = require('../schema/m_suppliers');
// const PosMenu = require('../schema/pos/menu')
// const sequelize = require('./models/index');
const Message = require('../schema/chat/Message'); // Messageモデルをインポート

// sequelize.sync()
//     .then(() => {
//         console.log('Database & tables created!');
//     })
//     .catch(error => {
//         console.error('Unable to connect to the database:', error);
//     });


//LIBS
const pdf = require('html-pdf');
const ejs = require('ejs');
const { Op, Sequelize } = require('sequelize');



//middleware
router.use(function timelog(req, res, next) {
  console.log('Time: ', Date.now());
  next();
});

router.get('/KetsugouTestcostRestGet', async (req, res) => {
  try {
   const costrestsWithSuppliers = await Costrest.findAll({
     include: [
       {
         model: Suppliers,
         as: 'supplier',
         attributes: ['name_jp'], // 取得する列を指定
       },
       {
         model: Costcategory,
         as: 'kamokus',
         attributes: ['name_jp'], // AnotherTableテーブルから取得する列を指定
       },
     ],
      where: {
        // ここに条件を追加
        // 例: idが1のものだけ取得する場合
        category: req.query.category,
      },
   });
res.json(costrestsWithSuppliers)
   // return costrestsWithSuppliers;
 } catch (error) {
   console.error('Error getting costrests with suppliers:', error);
   throw error;
 }
});



router.get('/getsupplires', async (req, res) => {
  try {
  const supplireget = await Suppliers.findAll({
  });
  res.json(supplireget)
} catch (err) {
  res.json(err)
  console.log(err)
}
});

//rota principal-------------------------->
router.get('/', (req, res) => {
  res.json({ message: 'funcionando', status: 200 });
});

//envio de e-mail----------------------------->
router.get('/mailer', async (req, res) => {
  try {
    let a = await mailer('./routs/hello.txt');
    res.send(a);
  }
  catch (err) {
    return res.status(400).json(err)
  }

});

router.get('/dakokusget', async (req, res) => {
  try {
  const dakokus = await Dakoku.findAll({
    where: {
      worker_id: req.query.id,
      workday: req.query.dt
    }
  });
  res.json(dakokus)
} catch (err) {
  res.json(err)
  console.log(err)
}
});

//rotas de testes------------------------------>
router.get('/client', async (req, res) => {
  try {
    await database.sync();

    const newClient = await myClient.create({
      GYM_NAME: 'marrone doe',
      REPRESENTATIVE: 'novo rep',
      UNIQUE_CODE: 2,
      PASSWORD: '1234',
      ADRESS: 'marrone doe',
      TEL: 999999999,
      EMAIL: 'john.doe@gmail.com',
      SAVE_DAY: '12-85-22',
      STATUS: 'ativo',
      LANGUAGE: 'EN'
    });
    res.json(newClient);

  } catch (err) {
    return res.status(400).json(err)
  }

});

//clients data get------------------------->
router.get('/clientesDados/:id', async (req, res) => {
  try {
  const members = await myClient.findAll({
    where: {
      id: req.params.id
    }
  }); //findAll findByPk


  res.json(members)
} catch (err) {
  res.json(err)
  console.log(err)
}
});

router.post('/ParentsCreate', async (req, res) => {
    try {
  var param = req.body;
  let newParents = await Parent.create({
    nm_member_id: param.id,
    family_name: param.name,
    birthday: param.birthday,
    gender: param.gender,
    birthday_age: param.age,
    gymid: param.gymid,
  });
   res.json(newParents);
   }
  catch (err) {
    return res.status(400).json(err)
    console.log(err)
  }
});

router.post('/updateorderHistory', async (req, res) => {
  try {
    console.log(154)
    console.log(req.body)
    const newClient = await Historyorder.update({
      menu_id: req.body.d1,
      menu_child_id: req.body.d2,
      menu_value: req.body.d3,
      quantity_menu: req.body.d4,
      opt1:req.body.d6,
      opt2:req.body.d7,
      opt3:req.body.d8,
      opt4:req.body.d9,
      opt5:req.body.d11,
      total_amount:req.body.d10
    },{
        where: {
          id: req.body.d5
        }
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/addnewzaiko', async (req, res) => {
    try {
      console.log(req.body)
  let newParents = await Iventory.create({
    rest_id:0,
    name:req.body.d0,
    quantity:req.body.d2 ,
    cust: req.body.d3,
    updt: req.body.d6,
    categorys: req.body.d1,
    mercado: req.body.d4,
    kijun: req.body.d5,
    tani:req.body.d7,
    suplires_id:req.body.d8
  });
   res.json(newParents);
   }
  catch (err) {
     console.log(err)
    return res.status(400).json(err)

  }
});

router.post('/updatefinaldakoku', async (req, res) => {
  try {
    const newClient = await Dakoku.update({
      fn: req.body.d2
    },{
        where: {
          id: req.body.d1
        }
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/dakokuupdt', async (req, res) => {
  try {
    const newClient = await Dakoku.update({
      st: req.body.d2
    },{
        where: {
          id: req.body.d1
        }
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/updatasOrderslist', async (req, res) => {
  try {
    const newClient = await Historyorder.update({
      paykubun: req.body.d1,
      pickUp_way: req.body.d0,
    },{
        where: {
          id: req.body.ids
        }
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/statusNotPickUp', async (req, res) => {
  try {
    const newClient = await Historyorder.update({
      status: 0
    },{
        where: {
          id: req.body.ids
        }
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});


router.get('/ordergetstatusyet', async (req, res) => {
  try {
  const clients = await Historyorder.findAll({
    where: {
      status: 0,
    }
  });
    res.json({
         clients
    })
} catch (err) {
  res.json({ message: 'internal error' })
}
});

router.post('/updateRestMenus', async (req, res) => {
  try {
    const newClient = await RestMenu.update({
      status: req.body.d1
    },{
        where: {
          id: req.body.d2
        }
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/editsmenus', async (req, res) => {
  try {
     const newClient = await RestMenu.update({
      menu_name_0:req.body.d0,
      menu_name_1:req.body.d1,
      menu_name_2:req.body.d2,
      menu_value:req.body.d3,
      control_name:req.body.d4,
      bbq_kubun:req.body.d5,

    },{
        where: {
          id:req.body.d6
        }
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.get('/gategorycostGet', async (req, res) => {
  try {
  const clients = await Costcategory.findAll({
  });
    res.json({
         clients
    })
} catch (err) {
  console.log(err)
  res.json({ message: 'internal error' })
}
});

router.get('/gategorycostGet2', async (req, res) => {
  try {
    console.log('haiterukedo2')
  const clients = await Iventory.findAll({
  });
    res.json({
         clients
    })
} catch (err) {
  console.log(err)
  res.json({ message: 'internal error' })
}
});

router.post('/changezaiko', async (req, res) => {
  try {
      const newClient = await Iventory.update({
        quantity: req.body.d0
      },{
          where: {
            id: req.body.d1
          }
      });
      res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});


router.post('/changezaikobyorderFinish', async (req, res) => {
  try {
    console.log('in341')
    const quantityChange = parseInt(req.body.d0); // req.body.dを数値に変換
     console.log(`idは${req.body.d1}`)
     console.log(req.body.d0)
    // Iventoryの該当レコードを取得
    const inventoryRecord = await Iventory.findOne({
      where: {
        id: req.body.d1
      }
    });
      console.log(inventoryRecord)
      console.log(350)
    if (!inventoryRecord) {
      return res.status(404).json({ error: 'Record not found' });
    }

    // quantityを計算して更新
    const newQuantity = inventoryRecord.quantity + quantityChange;
console.log(`最新が${newQuantity}`)
    // Iventoryを更新
    const updatedInventory = await Iventory.update(
      { quantity: newQuantity },
      { where: { id: req.body.d1 } }
    );

    res.json({ success: true, newQuantity });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});


//レストアプリの支出追加ルート------------------------------>
router.post('/createCostRest', async (req, res) => {
  try {
    console.log(req.body.d5)//'2024-02-20'
    const newClient = await Costrest.create({
      rest_id: req.body.d1,
      worker_id: req.body.d2,
      cost_id: req.body.d3,
      amount: req.body.d4,
      payday: req.body.d5,
      memo: req.body.d6,
      paykubun: req.body.d7,
      status: req.body.d8,
      seq:req.body.d9,
      suppliers_id:req.body.d10,
      checked_kubun:req.body.d11,
      category:req.body.d12
    });
    console.log(newClient.toJSON());
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/updatecostrest', async (req, res) => {
  try{
      const newClient = await Costrest.update({
        status: req.body[i].status
      },{
          where: {
            id: req.body.id
          }
      });
    return res.status(200).json('OK')
  }catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }

});


router.post('/updatechecked_kubun', async (req, res) => {
  try{
      const newClient = await Costrest.update({
        checked_kubun: req.body.kubun
      },{
          where: {
            id: req.body.id
          }
      });
    return res.status(200).json('OK')
  }catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }

});



router.post('/updatecostfluxo', async (req, res) => {
  try{
      const newClient = await Costrest.update({
        payday: req.body.d1,
        amount: req.body.d2,
        cost_id:req.body.d3,
        memo:req.body.d4,
        paykubun:req.body.d5,
        suppliers_id:req.body.d6
      },{
          where: {
            id: req.body.id
          }
      });
    return res.status(200).json('OK')
  }catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }

});

router.post('/destroycost', async (req, res) => {

  try {
    Costrest.destroy({ where: { id: req.body.id } })
    return res.status(200).json('OK')
  }
  catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }

});

router.post('/dakokuistfinaldata', async (req, res) => {
  try {
    const newClient = await Dakoku.create({
      worker_id: req.body.d1,
      fn: req.body.d2,
      workday: req.body.d3
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/dakokuistdata', async (req, res) => {
  try {
    const newClient = await Dakoku.create({
      worker_id: req.body.d1,
      st: req.body.d2,
      workday: req.body.d3
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});


router.post('/updateBBQmenus', async (req, res) => {
  try {
    let bbqkubun = 0
    if(req.body.d1==1){
      bbqkubun = 1
    }
    const newClient = await RestMenu.update({
      status: bbqkubun
    },{
        where: {
          bbq_kubun: 1
        }
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});





router.post('/updateAllmenus', async (req, res) => {
  try{
    for(let i=0;i<req.body.length;i++){
      const newClient = await RestMenu.update({
        status: req.body[i].status
      },{
          where: {
            id: req.body[i].id
          }
      });
    }
    return res.status(200).json('OK')
  }catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }

});

//レストアプリの収出テーブルから取得------------------------->
router.get('/costRestGet', async (req, res) => {
  try {
  const members = await Costrest.findAll({
    where: {
      rest_id: req.query.id
    }
  }); //findAll findByPk
  res.json(members)
} catch (err) {
  res.json(err)
  console.log(err)
}
});

router.get('/serchcosts', async (req, res) => {
  try {
  if(req.query.costid!=0){
    const costs = await Costrest.findAll({
      where: {
        rest_id: req.query.id,
        cost_id: req.query.costid,
        payday :{
          [Op.between]:[req.query.stdt,req.query.fndt]
        }
      }
    });
    res.json(costs)
  }else{
    const costs = await Costrest.findAll({
      where: {
        rest_id: req.query.id,
        payday :{
          [Op.between]:[req.query.stdt,req.query.fndt]
        }
      }
    });
    res.json(costs)
  }
} catch (err) {
  res.json(err)
  console.log(err)
}
});

router.get('/serchsyunyuu', async (req, res) => {
  try {
    const costs = await Historyorder.findAll({
      where: {
        rest_id: req.query.id,
        pickUp_day :{
          [Op.between]:[req.query.stdt,req.query.fndt]
        }
      }
    });
    res.json(costs)
    } catch (err) {
      res.json(err)
      console.log(err)
    }
});

router.get('/serchcostsidselects', async (req, res) => {
  try {
    const costs = await Costrest.findAll({
      where: {
        id: req.query.id
      }
    });
    res.json(costs)
} catch (err) {
  res.json(err)
  console.log(err)
}
});

router.post('/createcaixadata', async (req, res) => {
  try {
    const newClient = await CloseCaixa.create({
      rest_id: req.body.d1,
      p_day: req.body.d2,
      start: req.body.d3,
      crete_id:req.body.d4,
      demae:0,
      uber:0,
      finel_id:0,
      squere:0,
      final:0
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.get('/caixaCloseGet', async (req, res) => {
  try {
    console.log(req.query.dt)
    console.log(req.query.id)
  const caixa = await CloseCaixa.findAll({
    where: {
      p_day: req.query.dt,
      rest_id:req.query.id
    }
  }); //findAll findByPk
  res.json(caixa)
} catch (err) {
  res.json(err)
  console.log(err)
}
});
//update do caixa history------------------------------->
router.post('/caixaupdates', async (req, res) => {
  try{
  const members = await CloseCaixa.update({
    finel_id:d0,
    uber:d1,
    squere:d2,
    demae:d3,
    final:d4,
    obs:d5
  }, {
    where: {
      id: req.body.id
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400)
}
});

//rotas de testes------------------------------>
router.post('/clientTest', async (req, res) => {
  try {
   // await database.sync();

    const newClient = await myClient.create({
      GYM_NAME: req.body.gymname,
      REPRESENTATIVE: req.body.rep,
      UNIQUE_CODE: 5,
      PASSWORD: req.body.pass,
      ADRESS: req.body.end,
      TEL: req.body.tel,
      EMAIL: req.body.email,
      SAVE_DAY: req.body.save,
      STATUS: 'ativo',
      LANGUAGE: req.body.language
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});



// 支出履歴の登録
router.post('/expenseHistory', async (req, res) => {
  try {
    const newClient = await Expense.create({
      category: req.body.category,
      expense_id: req.body.id,
      GYM_ID: req.body.gymid,
      NAME: req.body.name,
      KAKAKU: req.body.value,
      COLOR: req.body.color,
      KUBUN: req.body.kubun,
      STATUS: req.body.status,
      Date: req.body.date,
      note: req.body.note
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/expenseHistoryupdate', async (req, res) => {
  try {
    const newClient = await Expense.update({
      category: req.body.category,
      expense_id: req.body.id,
      GYM_ID: req.body.gymid,
      NAME: req.body.name,
      KAKAKU: req.body.value,
      COLOR: req.body.color,
      KUBUN: req.body.kubun,
      STATUS: req.body.status,
      Date: req.body.date,
      note: req.body.note
    },{
        where: {
          id: req.body.upid
        }
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});


//支出項目の登録------------------------------>
router.post('/createexpenses', async (req, res) => {
  try {
    const newExpense = await Finencepay.create({
      GYM_ID: req.body.id,
      CATEGORY: req.body.category,
      NAME: req.body.name,
      VALUE:req.body.value,
      COLOR: req.body.color,
      KUBUN: req.body.kubun,
      Date: req.body.date
    });
    res.json(newExpense);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

//rotas de testes------------------------------>
router.post('/createCategory', async (req, res) => {
  try {
  //  await database.sync();
    const newClient = await Finence_category.create({
      GYM_ID: req.body.id,
      CATEGORY: req.body.category,
      KUBUN: req.body.kubun,
      COLOR: req.body.color
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

//メンバー数カウントGET------------------------->
router.get('/membersCount', async (req, res) => {
  try {
  const memberscount = await MemberCount.findAll({
    where: {
      GYM_ID: req.query.id
    }
  });
  res.json(memberscount)
} catch (err) {
  res.json(err)
}
});

//支出の履歴取得------------------------->
router.get('/expensesHistoryGet', async (req, res) => {
  try {
    const { Op } = require('sequelize')
  const clients = await Expense.findAll({
    where: {
      GYM_ID: req.query.id,
       Date :{
         [Op.gt]:req.query.getdat
       } ,
       kubun: req.query.kubun
    }
  });
  res.json(clients)
} catch (err) {
  res.json(err)
}
});

//支出のアイテム名をGET------------------------->
router.get('/finenceGet', async (req, res) => {
  try {
  const memberscount = await Finencepay.findAll({
    where: {
      GYM_ID: req.query.id,
      KUBUN:req.query.kubun
    }
  });
  res.json(memberscount)
} catch (err) {
  res.json(err)
}
});

//支出のアイテム名をGET------------------------->
router.get('/finenceCategoryGet', async (req, res) => {
  try {
  const memberscount = await Finence_category.findAll({
    where: {
      GYM_ID: req.query.id,
      KUBUN:req.query.kubun
    }
  });
  res.json(memberscount)
} catch (err) {
  res.json(err)
}
});

//autenticação de usuario------------------------>
router.post('/authRestmember', async (req, res) => {
  try {
      const [numbers, password] = [req.body.numbers, req.body.password];
      const clients = await Restadmin.findAll({
        where: {
          adress: numbers,
          password: password
        }
      });
    let name = clients[0].rest_id;
    let code = clients[0].worker_name;
    var gymname = clients[0].status;
    res.json(clients)
  } catch (err) {
    res.json({ message: 'internal error' })
  }

});

router.get('/getworkernamerest', async (req, res) => {
  try {
      const clients = await Restadmin.findAll({
        where: {
          id:req.query.id
        }
      });
    res.json(clients)
  } catch (err) {
    res.json({ message: 'internal error' })
  }

})

//autenticação de usuario------------------------>
router.post('/auth', async (req, res) => {
  const [numbers, password] = [req.body.numbers, req.body.password];
  const [primaryKey, secondKey] = [1234, 567]
  const clients = await myClient.findAll({
    where: {
      GYM_NAME: numbers,
      PASSWORD: password
    }
  });
  try {
    let name = clients[0].REPRESENTATIVE;
    let code = clients[0].UNIQUE_CODE;
    var gymname = clients[0].GYM_NAME;
    var id = clients[0].id
    var language = clients[0].LANGUAGE
    switch (code) {
      case '1':
        validationRes(primaryKey, name, code, gymname, id, language)
        break;
      case '2':
        validationRes(secondKey, name, code, gymname, id, language)
        break;
      default:
        console.log("eroor")
    };

    function validationRes(key, name, code, gymname, id, language) {
      if (key > 0) {
        res.json({
          status: 200,
          token: key,
          gym: gymname,
          language: language,
          number: { NAME: name, AUTHORITY: code , ID: id },
        });
      } else {
        res.json({ message: 'internal error1' })
      }
    };
  } catch (err) {
    res.json({ message: 'internal error' })
  }

});

router.get('/trygyminfo', async (req, res) => {
  const members = await Member.findAll({
    where: {
      status: "active",
      gymid: req.query.id,
    }
  });
  res.json(members)
});

//insert de dados-------------------------------->
router.post('/member', async (req, res) => {
  try {
    await database.sync();
    const newMember = await Member.create({
      nm_member: req.body.nm_member,
      birthday_year: req.body.birthday_year,
      birthday_month: req.body.birthday_month,
      birthday_day: req.body.birthday_day,
      birthday_age: req.body.birthday_age,
      genero: req.body.genero,
      adress_input: req.body.adress_input,
      phone01: req.body.phone01,
      phone02: req.body.phone02,
      phone03: req.body.phone03,
      email: req.body.email,
      lang01: req.body.lang01,
      plans: req.body.plans,
      status: "active",
      signature: req.body.signature,
      pass: req.body.phone03,
      gym: req.body.gymname,
      gymid: req.body.gymid,
      active_date: req.body.active_date,
  		inactive_date: req.body.inactive_date
    });
    res.json(newMember);
  }
  catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }

});

//insert de dados-------------------------------->USE MYSQL TRIGGER
//router.post('/graduation', async (req, res) => {
  //try {
  //  await database.sync();
     //   const newgraduation = await Graduation.create({
    //  nm_member: req.body.nm_member,
   //   color: req.body.color,
    //  status: req.body.status,
   //   graduation_dt: req.body.graduation_dt,
    //  first_point: req.body.first_point,
    //  second_point: req.body.second_point,
    //  third_point: req.body.third_point,
    //  fourth_point: req.body.fourth_point,
     // lesson_after: req.body.lesson_after,
     // obs: req.body.obs,
     // gym: req.body.gymname
   // });
   // res.json(newgraduation);
  //}
 // catch (err) {
 //   return res.status(400).json(err)
 // }
//});

//read de dados------------------------------->
router.get('/info', async (req, res) => {
  const members = await Member.findAll({
    where: {
      status: "active"
    }
  }); //findAll findByPk

  res.json(members.length)

});

//read de dados------------------------------->
router.get('/paymentall', async (req, res) => {
  const members = await Pay.findAll({
    where: {
    division: 1
  }
  });
  res.json(members)
});

//read de dados do pay------------------------------->
router.post('/getpaymentAll', async (req, res) => {
   try{
  const members = await Pay.findAll({
    where: {
      year: req.body.year,
      GYM_ID: req.body.gymid
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});


//get de dados do pay------------------------------->
router.get('/gymgetpaymentAll', async (req, res) => {  //req.query
   try{
  const paymentdata = await Pay.findAll({
 where: {
     year: req.query.year,
     GYM_ID: req.query.id
    }
  });
  res.json(paymentdata)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//get dos planos------------------------------->
router.get('/gymplanget', async (req, res) => {
  try{
    const plans = await Plan.findAll({
      where:{
        GYM_ID: req.query.id
      }
    }); //findAll findByPk
    res.json(plans)
  }catch(err) {
    console.log(err)
   return res.status(400).json(err)
  }
});
//get dos membros da academia------------------------------->
router.get('/gymmemberlist', async (req, res) => {
  console.log('in')
  console.log(req.query.id)
  try{
    let memberslist = await Member.findAll({
      where:{
        gymid: req.query.id
      }
    }); //findAll findByPk
    res.json(memberslist)
  }catch(err) {
    console.log(err)
   return res.status(400).json(err)
  }
});

//checar se existe dados do request------------------------------->
router.get('/gympaymonthcheck', async (req, res) => {
  try{
    let chechanswer = await Pay.findAll({
      where:{
        year: req.query.year,
        month: req.query.month,
        nm_member_id: req.query.id
      }
    }); //findAll findByPk
    res.json(chechanswer)
  }catch(err) {
    console.log(err)
   return res.status(400).json(err)
  }
});

//read de dados------------------------------->
router.post('/family', async (req, res) => {
  try{
  const members = await Parent.findAll({
    where: {
      nm_member_id: req.body.id
    }
  }); //findAll findByPk

  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//read de dados------------------------------->
router.get('/newfamily', async (req, res) => {
  try{
  const members = await Parent.findAll({
    where: {
      nm_member_id: req.query.id
    }
  }); //findAll findByPk
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});


//Rota para recuperar DADOS do calendario para o front do entrance
router.get('/calender/gymentrance', async (req, res) => {
  const newCalender = await Calender.findAll({
    where: {
      DAY: atualDay(),
      GYM_ID:req.query.id
     }
  });
  res.json(newCalender)
  function atualDay() {
    //new Date(Date.now() + ((new Date().getTimezoneOffset() + (9 * 60)) * 60 * 1000));
    const japanStandardTime = new Date(Date.now() + ((new Date().getTimezoneOffset() + (9 * 60)) * 60 * 1000));
   // const japantime = new Date(japanStandardTime)
    const japanweekeday = japanStandardTime.getDay()
     switch (japanweekeday) {
      case 0:
        return 'sunday';
      case 1:
        return 'monday';
      case 2:
        return 'tuesday';
      case 3:
        return 'wednesday';
      case 4:
        return 'thursday';
      case 5:
        return 'friday';
      case 6:
        return 'saturday';
      default:
    };
  };
});


//update do familiar------------------------------->
router.post('/familyupdate', async (req, res) => {
  try{
  const members = await Parent.update({
    family_name:req.body.name,
    birthday:req.body.birth,
    gender:req.body.gender,
    birthday_age:req.body.age
  }, {
    where: {
      id: req.body.id
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400)
}
});

router.post('/updatehistoryStatus', async (req, res) => {
  try{
  const members = await Historyorder.update({
    status:req.body.status
  }, {
    where: {
      id:req.body.d1
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

router.post('/updatehistoryprapareStatus', async (req, res) => {
  try{
  const members = await Historyorder.update({
    prepare_status:req.body.status
  }, {
    where: {
      id:req.body.d1
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

router.post('/updatehistorypayed', async (req, res) => {
  try{
  const members = await Historyorder.update({
    pay_status:req.body.status
  }, {
    where: {
      id:req.body.d1
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//update dos dados do membro na graduação------------------------------->
router.post('/graduationmemberupdate', async (req, res) => {
  try{
  const members = await Graduation.update({
    nm_member:req.body.name,
    status:req.body.status,
  }, {
    where: {
      nm_member_id: req.body.id
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//update do pass------------------------------->
router.post('/passupdate', async (req, res) => {
  try{
  const members = await myClient.update({
    PASSWORD:req.body.pass,
  }, {
    where: {
      id: req.body.id
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//read de dados do pay------------------------------->
router.post('/paymentallexist', async (req, res) => {
   try{
  const members = await Pay.findAll({
    where: {
      year: req.body.year,
      month: req.body.month,
      GYM_ID: req.body.gymid
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//create de dados do pay------------------------------->
router.post('/createpayment', async (req, res) => {
   try{
       let newPay = await Pay.create({
         nm_member_id: req.body.id,
         nm_member: req.body.name,
         year: req.body.year,
         month: req.body.month,
         division: req.body.division,
         obs: 0,
         plan: req.body.plans,
         GYM_ID: req.body.gymid,
         plan_value: req.body.valor
        });
     res.json(newPay)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});



//create de dados do pay------------------------------->
router.post('/createplans', async (req, res) => {
   try{
       let newPlan = await Plan.create({
         GYM_ID: req.body.id,
         PLANS_NAME: req.body.name,
         PLAN_VALOR: req.body.valor,
         PLAN_KUBUN: req.body.kubun,
         PLAN_DISCRITION1: req.body.dis1,
         PLAN_DISCRITION2: req.body.dis2,
         PLAN_DISCRITION3: req.body.dis3,
         PLAN_DISCRITION4: req.body.dis4,
         PLAN_DISCRITION5: req.body.dis5,
         CONTROL_NAME: req.body.controlname,
         AGE: req.body.age,
        });
     res.json(newPlan)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//read dos planos------------------------------->
router.get('/planget', async (req, res) => {
  const plans = await Plan.findAll({
  }); //findAll findByPk

  res.json(plans)

});

//pay table Update---------------------------------->
router.post('/paymentUpdate', async (req, res) => {
 try{
  const members = await Pay.update({
    division:req.body.division
  }, {
    where: {
      nm_member_id: req.body.id,
      year: req.body.year,
      month: req.body.month,
    }
  });
  return res.json(members)
 } catch(err) {
   console.log(err)
  return res.status(400).json(err)
 }
});

//client  Update---------------------------------->
router.post('/clientUpdate', async (req, res) => {
 try{
  const members = await myClient.update({
    GYM_NAME:req.body.name2,
    REPRESENTATIVE:req.body.name1,
    TEL:req.body.tel,
    EMAIL:req.body.email,
    LANGUAGE:req.body.language
  }, {
    where: {
      id: req.body.id,
    }
  });
  return res.json(members)
 } catch(err) {
   console.log(err)
  return res.status(400).json(err)
 }
});

router.post('/updatehistoryPayStatus', async (req, res) => {
  try{
  const members = await Historyorder.update({
    paykubun:req.body.status
  }, {
    where: {
      id:req.body.id
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

router.post('/updatehistoryPicupStatus', async (req, res) => {
  try{
  const members = await Historyorder.update({
    pickUp_way:req.body.status
  }, {
    where: {
      id:req.body.id
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});
router.post('/updatehistoryUtenStatus', async (req, res) => {
  try{
  const members = await Historyorder.update({
    cutlery:req.body.status
  }, {
    where: {
      id:req.body.id
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//client  Age Update---------------------------------->
router.post('/memberAgeUpdate', async (req, res) => {
 try{
  const members = await Member.update({
    birthday_age:req.body.age,
  }, {
    where: {
      id: req.body.id,
    }
  });
  return res.json(members)
 } catch(err) {
  return res.status(400).json(err)
 }
});


//client  Update---------------------------------->
router.post('/planUpdate', async (req, res) => {
 try{
  const members = await Plan.update({
    PLANS_NAME:req.body.name,
    PLAN_VALOR:req.body.pvalue,
    PLAN_KUBUN:req.body.divi,
    PLAN_DISCRITION1:req.body.dis1,
    PLAN_DISCRITION2:req.body.dis2,
    PLAN_DISCRITION3:req.body.dis3,
    PLAN_DISCRITION4:req.body.dis4,
    PLAN_DISCRITION5:req.body.dis5,
    CONTROL_NAME:req.body.controlname,
  }, {
    where: {
      id: req.body.id,
    }
  });
  return res.json(members)
 } catch(err) {
   console.log(err)
  return res.status(400).json(err)
 }
});

//checar se existe os dados do mês------------------------------->
router.post('/paymonthcheck', async (req, res) => {
   try{
  const members = await Pay.findAll({
    where: {
      year: req.body.year,
      month: req.body.month,
      nm_member_id: req.body.id
    }
  });
  res.json(members)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//List Alunos---------------------------------->
router.post('/list', async (req, res) => {
  var filter1 = req.body.opt1;
  var filter2 = req.body.opt2;

  if (filter1 == 'All') { //executar filtro em todos os registros
    let members = await Member.findAll();
    res.json(members)
  }

  else if (filter1 != 'teenagers' && filter1 != '' && filter2 != '') { //executar com dois filtros
    let members = await Member.findAll({
      where: {
        genero: filter1,
        plans: filter2
      }
    });
    res.json(members)
  }

  else if (filter1 == 'teenagers' && filter2 != '') { //executar com filtro para menores de 18 com o filtro do plano
    let members = await Member.findAll({
      where: {
        birthday_age: {
          [Op.lte]: 18,
        },
        plans: filter2
      }
    });
    res.json(members)
  }

  else if (filter1 == 'teenagers' && filter2 == '') { //executar com filtro para menores de 18 sem filtro do plano
    let members = await Member.findAll({
      where: {
        birthday_age: {
          [Op.lte]: 18,
        },
      }
    });
    res.json(members)
  }

  else if (filter1 != '') {
    let members = await Member.findAll({ //executar apenas com o primeiro filtro
      where: {
        genero: filter1,
      }
    });
    res.json(members)
  }

  else if (filter2 != '') {
    let members = await Member.findAll({ //executar apenas com o segundo filtro
      where: {
        plans: filter2,
      }
    });
    res.json(members)
  }

  else if (filter1 == '' && filter2 == '') {
    let members = await Member.findAll(); //executar sem os filtros, busca todos regitros do banco
    res.json(members);
  }

});

//List graduation---------------------------------->
router.post('/graduationlist', async (req, res) => {
  var filter1 = req.body.opt1;
  var filter2 = req.body.opt2;
let members = await Graduation.findAll();
  res.json(members);
});

//昇格管理テーブルを全セレクト------------------------------->
router.get('/gymgraduationlist', async (req, res) => {
  try{
    let graduationlist = await Graduation.findAll({
      where:{
        GYM_ID: req.query.id,
      }
    }); //findAll findByPk
    res.json(graduationlist)
  }catch(err) {
    console.log(err)
   return res.status(400).json(err)
  }
});

//未支払い者を支払い管理テーブルセレクト------------------------------->
router.get('/gympaymentall', async (req, res) => {
  const paymentlist = await Pay.findAll({
    where: {
    division: 1,
    GYM_ID: req.query.id,
  }
  });
  res.json(paymentlist)
});

//アクティブメンバー数をセレクト------------------------------->
router.get('/gyminfo', async (req, res) => {
  const members = await Member.findAll({
    where: {
      status: "active",
      gymid: req.query.id,
    }
  }); //findAll findByPk
  res.json(members)
});

//カレンダーテーブルから全レッスン取得
router.get('/gymcalenderGet', async (req, res) => {
  const newCalender = await Calender.findAll({
    where: {
      GYM_ID: req.query.id,
    }
  });
  res.json(newCalender)
});


//入場履歴の照会------------------------------->
router.get('/gymEntrancehistory', async (req, res) => {
    const { Op } = require('sequelize')
  const members = await Entrance.findAll({
    where: {
      LESSON_DATE: {
        [Op.gt]:req.query.entrancedate
      },
      GYM_ID:req.query.id
    }
  }); //findAll findByPk
  res.json(members)
});

//List Alunos Update---------------------------------->
router.post('/listUpdate', async (req, res) => {
 try{
  const members = await Member.update({
    nm_member: req.body.nm_member,
    birthday_year: req.body.birth1,
    birthday_month: req.body.birth2,
    birthday_day: req.body.birth3,
    birthday_age: req.body.age,
    genero: req.body.gender,
    adress_input: req.body.address,
    phone01: req.body.tel1,
    phone02: req.body.tel2,
    phone03: req.body.tel3,
    email: req.body.email,
    lang01: req.body.language,
    plans: req.body.plan,
    status: req.body.status,
    pass: req.body.pass,
  }, {
    where: {
      id: req.body.id,
    }
  });
  return res.json(members)
 } catch(err) {
   console.log(err)
  return res.status(400).json(err)
 }
});


//List Graduação Update---------------------------------->
router.post('/graduationUpdate', async (req, res) => {
 try{

  const members = await Graduation.update({
    color: req.body.color,
    status: req.body.status,
    graduation_dt: req.body.graduation_dt,
    first_point: req.body.first_point,
    second_point: req.body.second_point,
    third_point: req.body.third_point,
    fourth_point: req.body.fourth_point,
    lesson_after: req.body.lesson_after,
     obs:req.body.obs,
  }, {
    where: {
      nm_member_id: req.body.id,
    }
  });
  res.json(members)
 } catch(err) {
  return res.status(400).json(err)
 }
});

  //ダッシュボードから支払いの更新------------------------------------------>
router.post('/payUpdatedashbord', async (req, res) => {
 try{
  const members = await Pay.update({
    division: '2'
  }, {
    where: {
      id: req.body.id,
    }
  });
  res.json(members)
 } catch(err) {
   res.status(400).json(err)
 }
});

// Graduação Update da quantidade de aulas---------------------------------->
router.post('/graduationafter', async (req, res) => {
 try{
  const members = await Graduation.update({
    lesson_after: req.body.lesson_after
  }, {
    where: {
      nm_member_id: req.body.id,
    }
  });
  res.json(members)
 } catch(err) {
  return res.status(400).json(err)
 }
});


  //支出カテゴリーのアップデート------------------------------------------>
router.post('/categoryupdate', async (req, res) => {
try{
const members = await Finence_category.update({
  CATEGORY: req.body.category,
  KUBUN:'1',
  COLOR:req.body.color,

}, {
  where: {
    id: req.body.id,
  }
});
res.json(members)
} catch(err) {
 res.status(400).json(err)
}
});


//rota para verificar graduação-------------------------------------------->
router.get('/lesson_after/:id', async (req, res) => {
  try{
   let index = req.params.id;
    const grau = await Graduation.findAll({
      where: { nm_member_id: index }
    });

    if (grau[0].lesson_after === "39") {
      await mailerGrau(grau[0].nm_member);
    };
    res.send("enviado");
  } catch(err) {
    return res.status(400).json(err)
  };

});


//rota para enviar email de contacto-------------------------------------------->
router.post('/restaurantContact', async (req, res) => {
  try{
      await restaurant(req.body.name,req.body.tel,req.body.email,req.body.mens);
    res.send("enviado");
  } catch(err) {
    return res.status(400).json(err)
  };
});

//list alunos delete------------------->
router.post('/listDelete', async (req, res) => {
  Member.destroy({ where: { id: req.body.id } })
  Graduation.destroy({ where: { nm_member_id: req.body.id } })
  Pay.destroy({ where: { nm_member_id: req.body.id } })
  Parent.destroy({ where: { nm_member_id: req.body.id } })
  res.json('deletado');
});

//支出カテゴリーを削除します------------------->
router.post('/destroyCategory', async (req, res) => {
  Finence_category.destroy({ where: { id: req.body.id } })
  try {
    const newCalender = await Expense.update({
      category: 0,
      COLOR: '#8B4513'
    }, {
      where: {
        category: req.body.id,
      }
    });
    res.json(newCalender)
  }
  catch (err) { console.log(err) }

});

//支出項目を削除します------------------->
router.post('/FinencepayCategory', async (req, res) => {
  Finencepay.destroy({ where: { id: req.body.id } })
  try {
    const newCalender = await Expense.update({
      category: '0',
      COLOR: '#8B4513',
      expense_id: '0'
    }, {
      where: {
        expense_id: req.body.id,
      }
    });
    res.json(newCalender)
  }
  catch (err) { console.log(err) }

});

router.post('/familyDelete', async (req, res) => {
  Parent.destroy({ where: { id: req.body.id } })
  res.json('deletado');
})


router.post('/planDelete', async (req, res) => {
  Plan.destroy({ where: { id: req.body.id } })
  res.json('deletado');
})

router.post('/expenseHistoryDelete', async (req, res) => {
  Expense.destroy({ where: { id: req.body.id } })
  res.json('deletado');
})

//gerar PDF inscrição
router.get('/pdf', async (req, response) => {
try{
  const countMax = await Member.findAll({
    attributes: [[Sequelize.fn('max', Sequelize.col('id')), 'id']],
    raw: true,
  });
  const members = await Member.findAll({
    where: {
      id: countMax[0].id
    }
  });

  const client = await myClient.findAll({
    where: {
      GYM_NAME: members[0].gym
    }
   });

  var obj = {
    'uuid': members[0].id.toString(),
    'nm_member': members[0].nm_member,
    'birthday': `${members[0].birthday_year}/${members[0].birthday_month}/${members[0].birthday_day}`,
    'genero': members[0].genero,
    'adress': members[0].adress_input,
    'phone': `0${members[0].phone01}-${members[0].phone02}-${members[0].phone03}`,
    'email': members[0].email,
    'language': members[0].lang01,
    'plan': members[0].plans,
    'signature': members[0].signature,
    'entryDate': new Intl.DateTimeFormat('ja-JP').format(members[0].createdAt),
    'gymname': members[0].gym
  };
  ejs.renderFile('./views/email.ejs', obj, async (err, html) => {
    if (err) {
      console.log("erro!!!!!")
    } else {
      pdf.create(html, { "orientation": "landscape", format: 'a10' })
        .toFile(`./historico/Ficha de Inscricao.pdf`, async (err, res) => {
          if (err) {
            console.log(err)
            console.log('erro')
          } else {
            //response.send(res)
            try {
              let memberEmail = await mailer(`./historico/Ficha de Inscricao.pdf`, obj.email, obj.nm_member, obj.language, client[0].LANGUAGE, client[0].EMAIL, obj.gymname);
              response.send(memberEmail);
            } catch (err) { console.log(err) }
          }
        });
      }
  });
} catch(err) {
  console.log(err)
 //return status(400).json(err)
}


});

//Rota para gerar pdf do calender
router.get('/pdf/calender', async (req, response) => {
  try {
    const newCalender = await Calender.findAll();
    await ejs.renderFile('./views/calender.ejs', {
      days: newCalender,
    }, async (err, html) => {
      if (err) {
        console.log("erro!!!!!", err)
      } else {
        pdf.create(html, { "orientation": "landscape" })
          .toFile(`./historico/teste.pdf`, async (err, res) => {
            if (err) {
              console.log('erro')
            } else {
              try {
                let a = await mailer(`./historico/teste.pdf`);
                response.send(a);
              } catch (err) { console.log(err) }
            }
          });
      }
    });
  }
  catch (err) { console.log(err) }
});

//Rota para atualizar DADOS do calendario
router.put('/calender', async (req, res) => {
    try {
      const newCalender = await Calender.update({
        GYM_ID: req.body.GYM,
        START_TIME: req.body.START,
        FINISH_TIME: req.body.FINISH,
        DESCRITION_1: req.body.DESC1,
        DESCRITION_2: req.body.DESC2,
        IMAGE:req.body.IMG,
        GRADUATION_FLUG: req.body.flug,
        COLOR: req.body.COLOR
      }, {
        where: {
          DAY: req.body.DAY,
          LINE_NO: req.body.LINE
        }
      });
      res.json(newCalender)
    }
    catch (err) { console.log(err) }
});


//Rota para recuperar DADOS do calendario
router.get('/calenderteste', async (req, res) => {
  const newCalender = await Calender.findAll();
  res.json(newCalender)
});

//Rota para recuperar DADOS do calendario para o front do entrance
router.get('/calender/entrance', async (req, res) => {
  const newCalender = await Calender.findAll({
    where: { DAY: atualDay() }
  });
  res.json(newCalender)

  function atualDay() {
    //new Date(Date.now() + ((new Date().getTimezoneOffset() + (9 * 60)) * 60 * 1000));
    const japanStandardTime = new Date(Date.now() + ((new Date().getTimezoneOffset() + (9 * 60)) * 60 * 1000));
   // const japantime = new Date(japanStandardTime)
    const japanweekeday = japanStandardTime.getDay()
     switch (japanweekeday) {
      case 0:
        return 'sunday';
      case 1:
        return 'monday';
      case 2:
        return 'tuesday';
      case 3:
        return 'wednesday';
      case 4:
        return 'thursday';
      case 5:
        return 'friday';
      case 6:
        return 'saturday';
      default:
        console.log('error..')
    };
  };

});

//Rota para registrar entradas da entrance
router.post('/registerEntrance', async (req, res) => {
  try {
    await database.sync();
    const newEntrance = await Entrance.create({
      LESSON_NAME: req.body.LESSON_NAME,
      LESSON_HOUR: req.body.LESSON_HOUR,
      MEMBER_ID: req.body.MEMBER_ID,
      GYM_ID: req.body.GYM_ID,
      LESSON_DATE: req.body.LESSON_DATE,
      LESSON_DAY: req.body.LESSON_DAY,
    });
    console.log(res)
    res.json(newEntrance)
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  };

});

//rota para verificar passe do aluno
router.post('/pass', async (req, res) => {
  const members = await Member.findAll({
    where: {
      pass: req.body.pass
    }
  });
  res.json(members)

});

//rota para pegar o history das aulas
router.post('/entrancehistory', async (req, res) => {
  const { Op } = require('sequelize')
  const members = await Entrance.findAll({
      where: {
      LESSON_DATE: {
        [Op.gt]:req.body.entrancedate
      }
    }
  });
  res.json(members)
});

//rota para pagamentos
router.get('/payment/:name/:gym_id/:plan/:valor', async (req, res) => {
  const countMax = await Member.findAll({
    attributes: [[Sequelize.fn('max', Sequelize.col('id')), 'id']],
    raw: true,
  });
  await console.log(countMax)
  var month = new Date().getMonth() +1;
  var year = new Date().getFullYear();
  var param = req.params;
  await database.sync();
    await console.log('in2')
  let newPay = await Pay.create({
    nm_member_id: countMax[0].id,
    nm_member: param.name,
    year: year,
    month: month,
    division: 1,
    obs: 0,
    plan: param.plan,
    GYM_ID: param.gym_id,
    plan_value: param.valor,
  });
  res.json(newPay);
});

//rota para criar dados dos parentes
router.get('/parents/:name/:birthday/:gender/:age/:gymid', async (req, res) => {
    try {
  const countMax = await Member.findAll({
    attributes: [[Sequelize.fn('max', Sequelize.col('id')), 'id']],
    raw: true,
  });
  var param = req.params;
  let newParents = await Parent.create({
    nm_member_id: countMax[0].id,
    family_name: param.name,
    birthday: param.birthday,
    gender: param.gender,
    birthday_age: param.age,
    gymid: param.gymid,
  });
   return res.status(200)
   }
  catch (err) {
    return res.status(400).json(err)
    console.log(err)
  }
});

router.post('/newParentsCreate', async (req, res) => {
    try {
      const countMax = await Member.findAll({
        attributes: [[Sequelize.fn('max', Sequelize.col('id')), 'id']],
        raw: true,
      });
  var param = req.body;
  let newParents = await Parent.create({
    nm_member_id: countMax[0].id,
    family_name: param.name,
    birthday: param.birthday,
    gender: param.gender,
    birthday_age: param.age,
    gymid: param.gymid,
  });
   return res.json(newParents)
   }
  catch (err) {
    return res.status(400).json(err)
    console.log(err)
  }
});

//Rotas para o app do rest------------------------------------------------------>
/////////////////////////////////////////////////////////////////////////////////

//rotas de testes------------------------------>
router.post('/newMemberRoots', async (req, res) => {
  try {
  //  await database.sync();
    const newClient = await RestClient.create({
      id: req.body.id,
      name: req.body.name,
      phone: req.body.phone,
      post: req.body.post,
      adress: req.body.adress,
      password:req.body.pass,
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

//router of login rest member----------------------------->
router.post('/authClients', async (req, res) => {
  const [numbers, password] = [req.body.numbers, req.body.password];
  const [primaryKey, secondKey] = [1234, 567]
  try {
  const clients = await RestClient.findAll({
    where: {
      phone: numbers,
      password: password
    }
  });
  console.log(clients)
  if(clients.length==0){
    res.json({ message: 'internal error' })
  }else{
    res.json({
         status: 200,
         name: clients[0].name,
         phone: clients[0].phone,
         post: clients[0].post,
         id: clients[0].id,
         adress: clients[0].adress,
          });
  }
} catch (err) {
  res.json({ message: 'internal error' })
}
});

//rest app menu Get------------------------>
router.get('/menuGet', async (req, res) => {
  console.log("in")
  console.log(req.query.id)
  console.log(req.query.menuid)
   try{
  const menuAnswer = await RestMenu.findAll({
   where: {
   rest_id: req.query.id,
   //menu_id: req.query.menuid
    }
  });
  res.json(menuAnswer)
} catch(err) {
  console.log(err)
 return res.status(400).json(err)
}
});

//-------------------Order rout--------------------------------------->
router.post('/newOrder', async (req, res) => {
  try {
    //const maxIdorder = maxorder()
    const newClient = await Historyorder.create({
        rest_id:req.body.d0,
      menu_id:req.body.d1,
      menu_child_id:req.body.d2,
      menu_value:req.body.d3,
      quantity_menu:req.body.d4,
      order_id:req.body.d5,
      status:0,
      client_name:req.body.d10 ,
      paykubun:(req.body.d6) ? req.body.d6 : 0,
      obs:(req.body.d9) ? req.body.d9 : "default value",
      pickUp_day:(req.body.d8) ? req.body.d8 : "default value",
      pickUp_way:(req.body.d7) ? req.body.d7 : 0,
      pay_status:0,
      prepare_status:0
    });
    res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/RegisterOrder', async (req, res) => {
  try {
    //const maxIdorder = maxorder()
    console.log(req.body)

    const newClient = await Historyorder.create({
      rest_id:req.body.d0,
      menu_id:req.body.d1,
      menu_child_id:req.body.d2,
      menu_value:req.body.d3,
      quantity_menu:req.body.d4,
      order_id:req.body.d5,
      status:0,
      client_name:(req.body.d10!="") ? req.body.d10 : 'Clients' ,
      paykubun:(req.body.d6) ? req.body.d6 : 0,
      obs:(req.body.d9) ? req.body.d9 : "default value",
      pickUp_day: req.body.d8.split(":")[0]+":"+req.body.d8.split(":")[1],
      pickUp_way:(req.body.d7) ? req.body.d7 : 0,
      pay_status:0,
      prepare_status:0,
      opt1:req.body.d11,
      opt2:req.body.d12,
      opt3:req.body.d13,
      opt4:req.body.d14,
      opt5:req.body.d19,
      opt6:req.body.d18,
      cutlery:req.body.d15,
      total_amount:req.body.d16,

    });

    const newOrderId = newClient.id; // これが新しいオーダーのID
    console.log(newOrderId)
    res.json({
      message: 'Order registered successfully',
      orderId: newOrderId,
      status:200
      // 他の必要な情報もここで返すことができます
    });


    // res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});



router.get('/orderdayscheck', async (req, res) => {
  try {
    const { Op } = require('sequelize');
    const startDate = new Date(req.query.getdat);
    const endDate = new Date(req.query.getdat);
    endDate.setDate(endDate.getDate() + 1); // 次の日の0時に設定する

    const clients = await Historyorder.findAll({
      where: {
        pickUp_day: {
          [Op.gte]: startDate,
          [Op.lt]: endDate
        }
      }
    });

    res.json({
      clients
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'internal error' });
  }
});



router.get('/orderget', async (req, res) => {
  try {
  const clients = await Historyorder.findAll({

  });
    res.json({
         clients
    })
} catch (err) {
  res.json({ message: 'internal error' })
}
});

router.get('/ordergetstatusconfirm', async (req, res) => {
  try {
  const clients = await Historyorder.findAll({
    where: {
      status: 1,
    }
  });
    res.json({
         clients
    })
} catch (err) {
  res.json({ message: 'internal error' })
}
});

//----------------------------SQUARE------------------------------------------>
router.post('/backend/create-payment-link', async (req, res) => {
  try {
    const crypto = require('crypto');
    const { Client, Environment } = require('square');
    console.log(req.body.amount)
    // Configure as informações do seu aplicativo Square
    const client = new Client({
      environment: Environment.Production,
      accessToken: credentials.production.accessToken
    });

    const response = await client.checkoutApi.createPaymentLink({
      idempotencyKey: crypto.randomUUID(),
      order: {
        locationId: credentials.production.locationId,
        lineItems: [
          {
            name: req.body.name,
            quantity: req.body.quantity,
            basePriceMoney: {
              amount: req.body.amount,
              currency: req.body.currency
            }
          }
        ]
      },
      checkoutOptions: {
        // redirectUrl: `http://127.0.0.1:8080/pages/confirmorder.html?id=${req.body.orderId}`,
        redirectUrl: `https://seashell-app-s8r4y.ondigitalocean.app/pages/confirmorder.html?id=${req.body.orderId}`,
        acceptedPaymentMethods: {
          applePay: true,
          googlePay: true,
          cashAppPay: true
        }
      }
    });

    res.json(response.result.paymentLink);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Failed to create payment link' });
  }
});



//clients data get------------------------->
router.get('/restmanegerTimeGet', async (req, res) => {
  try {
  const members = await Rest_maneger.findAll({
    where: {
      rest_id:0
    }
  }); //findAll findByPk

  res.json(members)
} catch (err) {
  res.json(err)
  console.log(err)
}
});

module.exports = router;

router.post('/cachChange', async (req, res) => {
  try {
    if(req.body.d0==0){
      const newClient = await Rest_maneger.update({
        cach: req.body.d2,
        bank: req.body.d3,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==1){
      const newClient = await Rest_maneger.update({
        cach: req.body.d3,
        bank: req.body.d2,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==2&&req.body.d1==1){
      const newClient = await Rest_maneger.update({
        uber: req.body.d2,
        bank: req.body.d3,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==2&&req.body.d1==0){
      const newClient = await Rest_maneger.update({
        uber: req.body.d2,
        cach: req.body.d3,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==3&&req.body.d1==1){
      const newClient = await Rest_maneger.update({
        squere: req.body.d2,
        bank: req.body.d3,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==3&&req.body.d1==0){
      const newClient = await Rest_maneger.update({
        squere: req.body.d2,
        cach: req.body.d3,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==4){
      const newClient = await Rest_maneger.update({
        cach2: req.body.d2,
        bank: req.body.d3,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==5){
      const newClient = await Rest_maneger.update({
        caixa: req.body.d2,
        bank: req.body.d3,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }

  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/cachChangeonly', async (req, res) => {
  try {
    if(req.body.d0==0){
      const newClient = await Rest_maneger.update({
        caixa: req.body.d1,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==1){
      const newClient = await Rest_maneger.update({
        squere: req.body.d1,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else{
      const newClient = await Rest_maneger.update({
        uber: req.body.d1,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }

  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/delehistoryorder', async (req, res) => {
  Historyorder.destroy({ where: { id: req.body.id } })
  res.json('deletado');
});

router.post('/openclosescahnge', async (req, res) => {
  try {
      const newClient = await Rest_maneger.update({
        pickup_time: req.body.d0,
        work_status: req.body.d1,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/deletesmenus', async (req, res) => {
  RestMenu.destroy({ where: { id: req.body.id } })
  res.json('deletado');
});

router.post('/caixaopen', async (req, res) => {
try {
   let nwvalue = await getscaixas(req.body.d0)
   let vl = nwvalue - req.body.d1

   if(req.body.d0==0){
     const newClient = await Rest_maneger.update({
       caixa: req.body.d1,
       cach: vl,
     },{
         where: {
           rest_id: 0
         }
     });
     res.json(newClient);
   }else{
     const newClient = await Rest_maneger.update({
       caixa: req.body.d1,
       cach2: vl,
     },{
         where: {
           rest_id: 0
         }
     });
     res.json(newClient);
   }
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});



async function getscaixas(d){
    const members = await Rest_maneger.findAll({
    });
    let tgt = 0
    if(d==0){
      tgt = members[0].cach
    }else if(d==1){
      tgt = members[0].cach2
    }
   return tgt
}

router.post('/confirmclosecaixa', async (req, res) => {
try {

  const newClient = await CloseCaixa.update({
    uber: req.body.d1,
    squere: req.body.d3,
    demae:req.body.d2,
    final:req.body.d4,
    obs:req.body.d7
  },{
      where: {
        id: req.body.d5
      }
  });

   let nwvalue = await getscaixas(req.body.d6)
   let vl = (nwvalue-0) + (req.body.d4 -0)

   if(req.body.d6==0){
     const newClient = await Rest_maneger.update({
       caixa: 0,
       cach: vl,
     },{
         where: {
           rest_id: 0
         }
     });
     res.json(newClient);
   }else{
     const newClient = await Rest_maneger.update({
       caixa: 0,
       cach2: vl,
     },{
         where: {
           rest_id: 0
         }
     });
     res.json(newClient);
   }
  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});

router.post('/cachChangeonlykaikei', async (req, res) => {
  try {
    console.log("CD is:"+ req.body.d0)
    if(req.body.d0==0){
      const newClient = await Rest_maneger.update({
        cach: req.body.d1,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==4){
      const newClient = await Rest_maneger.update({
        cach2: req.body.d1,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==1){
      const newClient = await Rest_maneger.update({
        squere: req.body.d1,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else if(req.body.d0==99){
      const newClient = await Rest_maneger.update({
        bank: req.body.d1,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }else{
      const newClient = await Rest_maneger.update({
        uber: req.body.d1,
      },{
          where: {
            rest_id: 0
          }
      });
      res.json(newClient);
    }

  } catch (err) {
    console.log(err)
    return res.status(400).json(err)
  }
});



//App KEirikun 2024/07/15 Created by Paulo
const KeiriUsers = require('../schema/keirikun/user.schema');
const SuppliresKeiri = require('../schema/keirikun/suppliers.schema')
const UserCategory = require('../schema/keirikun/UserCategory.schema');
const Category = require('../schema/keirikun/Category.schema');
const Client = require('../schema/keirikun/client.schema');
const FinancialRecord = require('../schema/keirikun/financial_records.schema');
// const { Client, Supplier } = require('../../models');
const jwt = require('jsonwebtoken'); // ここでjsonwebtokenをインポート
// const bcrypt = require('bcrypt'); // bcryptをインポート
const { encryptPassword, verifyPassword } = require('../libs/encypt/password-crypto'); // comparePasswordをverifyPasswordに変更



UserCategory.belongsTo(Category, { foreignKey: 'category_id', targetKey: 'identification_id' });
Category.hasMany(UserCategory, { foreignKey: 'category_id', sourceKey: 'identification_id' });

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  console.log('Token:', token); // トークンを表示

  if (!token) {
    console.log('Token is missing');
    return res.sendStatus(401);
  }

  jwt.verify(token, 'abracadabra', (err, user) => {
    if (err) {
      console.log('Token verification failed', err);
      return res.sendStatus(403);
    }
    console.log('Token verified successfully', user);
    req.user = user;
    next();
  });
};

router.get('/keirikun/masterdata/get', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId; // トークンから取得
    console.log('User ID:', userId); // ユーザーIDの内容をログ出力
    if (!userId) {
      return res.status(400).json({ success: false, message: 'User ID is required' });
    }

    // サプライヤーデータの取得
    const suppliers = await SuppliresKeiri.findAll({
      where: { user_id: userId }
    });

    // ユーザーカテゴリデータの取得
    const userCategories = await UserCategory.findAll({
      where: { user_id: userId },
      include: [{
        model: Category,
        required: true
      }]
    });

    const clients = await Client.findAll({
    where: { user_id: userId }
  });

    res.status(200).json({
      success: true,
      data: {
        suppliers,
        userCategories,
        clients
      }
    });
  } catch (err) {
    console.error('Error fetching master data:', err);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch master data',
      error: err.message
    });
  }
});

// 支出データの登録エンドポイント
router.post('/keirikun/data/regist/expenses', authenticateToken, async (req, res) => {
    try {
    const { userId, date, supplier, method, amount, memo, category } = req.body;
    console.log(supplier)
    console.log('user id is'+ userId)
    // 入力チェック
    if (!date || !supplier || !amount || !category) {
        return res.status(400).json({
            success: false,
            message: 'Required fields are missing'
        });
    }


        // データの登録
        const newRecord = await FinancialRecord.create({
            record_date: date,
            party_code: category,
            description: `取引先:${supplier} 内容:${memo}`,
            expense: parseFloat(amount.replace(/[^\d.-]/g, '')), // 金額を数値に変換
            user_id: userId,
            category_id: category,
            payment_method: method,
            created_at: new Date(),
            updated_at: new Date()
        });

        res.status(201).json({
            success: true,
            data: newRecord,
            message: 'Expense recorded successfully'
        });
    } catch (error) {
        console.error('Error recording expense:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to record expense',
            error: error.message
        });
    }
});

router.post('/keirikun/data/regist/income', authenticateToken, async (req, res) => {
  console.log(req.body)
  const { userId, date, clients, method, amount, memo, category } = req.body;

  // 入力チェック
  if (!date || !clients || !amount || !category) {
    console.log(2853)
    return res.status(400).json({
      success: false,
      message: 'Required fields are missing'
    });
  }

  try {
    // データの登録
    const newRecord = await FinancialRecord.create({
      record_date: date,
      payment_method: method,
      party_code: category,
      // party_name: client,
      description: `請求先:${clients} 内容:${memo}`,
      income: parseFloat(amount.replace(/[^\d.-]/g, '')), // 金額を数値に変換
      user_id: userId
    });

    res.status(201).json({
      success: true,
      data: newRecord,
      message: 'Income recorded successfully'
    });
  } catch (error) {
    console.error('Error recording income:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to record income',
      error: error.message
    });
  }
});

// router.put('/keirikun/settings/update', authenticateToken, async (req, res) => {
//     const userId = req.user.id; // トークンからユーザーIDを取得
//     const { password, email, language, invoice_number, company_name, phone_number } = req.body;
//
//     try {
//         const user = await User.findByPk(userId);
//         if (!user) {
//             return res.status(404).json({ success: false, message: 'User not found' });
//         }
//
//         user.password = password || user.password; // パスワードが提供されていない場合、既存のパスワードを保持
//         user.email = email || user.email;
//         user.language = language || user.language;
//         user.invoice_number = invoice_number || user.invoice_number;
//         user.company_name = company_name || user.company_name;
//         user.phone_number = phone_number || user.phone_number;
//
//         await user.save();
//
//         res.status(200).json({ success: true, message: 'Settings updated successfully' });
//     } catch (error) {
//         console.error('Error updating settings:', error);
//         res.status(500).json({ success: false, message: 'Failed to update settings' });
//     }
// });


router.get('/keirikun/data/history', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.userId; // トークンから取得
        const { date } = req.query; // クエリパラメータから日付を取得

        if (!userId) {
            return res.status(400).json({ success: false, message: 'User ID is required' });
        }

        if (!date) {
            return res.status(400).json({ success: false, message: 'Date is required' });
        }

        const startDate = new Date(date);
        const endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0);

        // 日付をUTCのISO形式の文字列に変換
        const startISO = startDate.toISOString();
        const endISO = new Date(endDate.setUTCHours(23, 59, 59, 999)).toISOString();

        console.log('startDate (ISO UTC):', startISO);
        console.log('endDate (ISO UTC):', endISO);

        // デバッグ用にSQLクエリをログ出力
        console.log('Executing SQL query: SELECT * FROM FinancialRecord WHERE user_id = ? AND record_date BETWEEN ? AND ?', [userId, startISO, endISO]);

        // 履歴データの取得
        const records = await FinancialRecord.findAll({
            where: {
                user_id: userId,
                record_date: {
                    [Sequelize.Op.between]: [startISO, endISO]
                }
            },
            order: [['record_date', 'DESC']]
        });

        if (records.length === 0) {
            console.log('No records found for the given date range.');
        } else {
            console.log('Records found:', records.length);
        }

        res.status(200).json({
            success: true,
            records
        });
    } catch (err) {
        console.error('Error fetching history data:', err);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch history data',
            error: err.message
        });
    }
});

router.put('/keirikun/data/update', authenticateToken, async (req, res) => {
    const { id, date, amount, memo } = req.body;

    console.log(req.body);
    try {
        const record = await FinancialRecord.findOne({ where: { id } });
        if (!record) {
            return res.status(404).json({ success: false, message: 'Record not found' });
        }
        record.record_date = date;
        if (record.income !== null) {
            record.income = amount;
        } else {
            record.expense = amount;
        }
        record.description = memo;
        await record.save();

        res.status(200).json({ success: true, message: 'Record updated successfully' });
    } catch (error) {
        console.error('Error updating record:', error);
        res.status(500).json({ success: false, message: 'Failed to update record' });
    }
});


router.delete('/keirikun/data/delete', authenticateToken, async (req, res) => {
    const { id } = req.body;

    try {
        const record = await FinancialRecord.findOne({ where: { id } });
        if (!record) {
            return res.status(404).json({ success: false, message: 'Record not found' });
        }

        await record.destroy();
        res.status(200).json({ success: true, message: 'Record deleted successfully' });
    } catch (error) {
        console.error('Error deleting record:', error);
        res.status(500).json({ success: false, message: 'Failed to delete record' });
    }
});

// ユーザー情報取得エンドポイント
router.get('/keirikun/user-info', authenticateToken, async (req, res) => {
    const userId = req.user.userId;
     console.log("ID is: "+userId)
    try {
        const user = await KeiriUsers.findByPk(userId);
        if (!user) {
            return res.status(404).json({ success: false, message: 'User not found' });
        }

        console.log(user)

        res.status(200).json({
            email: user.email,
            language: user.language,
            invoice_number: user.invoiceNumber,
            company_name: user.companyName,
            phone_number: user.phoneNumber
        });
    } catch (error) {
        console.error('Error fetching user info:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch user info' });
    }
});

// 設定更新エンドポイント
router.put('/keirikun/settings/update', authenticateToken, async (req, res) => {
    console.log('update backend its is');
    const userId = req.user.userId;
    console.log("ID is: " + userId);
    const { email, language, invoice_number, company_name, phone_number } = req.body;

    console.log(req.body);

    try {
        const user = await KeiriUsers.findByPk(userId);
        if (!user) {
            return res.status(404).json({ success: false, message: 'User not found' });
        }

        if (email) user.email = email;
        if (language) user.language = language;
        if (invoice_number) {
            console.log("Updating invoice_number: ", invoice_number);
            user.invoiceNumber = invoice_number;
        }
        if (company_name) {
            console.log("Updating company_name: ", company_name);
            user.companyName = company_name;
        }
        if (phone_number) {
            console.log("Updating phone_number: ", phone_number);
            user.phoneNumber = phone_number;
        }

        await user.save();

        res.status(200).json({ success: true, message: 'Settings updated successfully' });
    } catch (error) {
        console.error('Error updating settings:', error);
        res.status(500).json({ success: false, message: 'Failed to update settings' });
    }
});


// パスワード変更エンドポイント
router.put('/keirikun/settings/change-password', authenticateToken, async (req, res) => {
    const userId = req.user.userId;
    console.log("ID is: " + userId);
    const { current_password, new_password } = req.body;

    try {
        const user = await KeiriUsers.findByPk(userId);
        if (!user) {
            return res.status(404).json({ success: false, message: 'User not found' });
        }

        const validPassword = await verifyPassword(current_password, user.password); // comparePasswordをverifyPasswordに変更
        if (!validPassword) {
            return res.status(400).json({ success: false, message: 'Current password is incorrect' });
        }

        user.password = await encryptPassword(new_password);
        await user.save();

        res.status(200).json({ success: true, message: 'Password updated successfully' });
    } catch (error) {
        console.error('Error updating password:', error);
        res.status(500).json({ success: false, message: 'Failed to update password' });
    }
});

// 新しいトークンを発行するエンドポイント
router.post('/keirikun/new-token', authenticateToken, async (req, res) => {
    const userId = req.user.userId;
    const { language } = req.body;

    try {
        const user = await KeiriUsers.findByPk(userId);
        if (!user) {
            return res.status(404).json({ success: false, message: 'User not found' });
        }

        // 新しいトークンを作成
        const newToken = jwt.sign({ userId: user.id, language: language || user.language }, 'abracadabra', { expiresIn: '1h' });

        res.status(200).json({ success: true, token: newToken });
    } catch (error) {
        console.error('Error creating new token:', error);
        res.status(500).json({ success: false, message: 'Failed to create new token' });
    }
});


// 収入データ取得エンドポイント
router.get('/keirikun/data/income', authenticateToken, async (req, res) => {
    const userId = req.user.userId;
    const { date } = req.query;

    if (!date) {
        return res.status(400).json({ success: false, message: 'Date is required' });
    }

    const startDate = new Date(date);
    const endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0);
    const startISO = startDate.toISOString();
    const endISO = new Date(endDate.setUTCHours(23, 59, 59, 999)).toISOString();

    try {
        const records = await FinancialRecord.findAll({
            where: {
                user_id: userId,
                income: { [Op.ne]: null },
                record_date: {
                    [Op.between]: [startISO, endISO]
                }
            },
            attributes: ['record_date', 'income'],
            order: [['record_date', 'ASC']]
        });

        const data = records.map(record => ({
            date: record.record_date,
            amount: record.income
        }));

        res.status(200).json({ success: true, data });
    } catch (error) {
        console.error('Error fetching income data:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch income data' });
    }
});

// 支出データ取得エンドポイント
router.get('/keirikun/data/expense', authenticateToken, async (req, res) => {
    const userId = req.user.userId;
    const { date } = req.query;

    if (!date) {
        return res.status(400).json({ success: false, message: 'Date is required' });
    }

    const startDate = new Date(date);
    const endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0);
    const startISO = startDate.toISOString();
    const endISO = new Date(endDate.setUTCHours(23, 59, 59, 999)).toISOString();

    try {
        const records = await FinancialRecord.findAll({
            where: {
                user_id: userId,
                expense: { [Op.ne]: null },
                record_date: {
                    [Op.between]: [startISO, endISO]
                }
            },
            attributes: ['record_date', 'expense'],
            order: [['record_date', 'ASC']]
        });

        const data = records.map(record => ({
            date: record.record_date,
            amount: record.expense
        }));

        res.status(200).json({ success: true, data });
    } catch (error) {
        console.error('Error fetching expense data:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch expense data' });
    }
});

// クライアントとサプライヤーを取得するエンドポイント
router.get('/partners', authenticateToken, async (req, res) => {
    const userId = req.user.userId;

    try {
        // クライアントとサプライヤーを取得
        const clients = await Client.findAll({ where: { user_id: userId } });
        const suppliers = await SuppliresKeiri.findAll({ where: { user_id: userId } });

        res.json({ success: true, clients, suppliers });
    } catch (error) {
        console.error('Error fetching partners:', error);
        res.status(500).json({ success: false, message: 'An error occurred while fetching partners' });
    }
});

router.put('/partners/:type/:id', authenticateToken, async (req, res) => {
    const { type, id } = req.params;
    const updatedData = req.body;
    try {
        if (type === 'client') {
            await Client.update(updatedData, { where: { id } });
        } else if (type === 'supplier') {
            await SuppliresKeiri.update(updatedData, { where: { id } });
        } else {
            return res.status(400).json({ success: false, message: 'Invalid type' });
        }
        res.json({ success: true, message: 'Partner updated successfully' });
    } catch (error) {
        console.error('Error updating partner:', error);
        res.status(500).json({ success: false, message: 'Failed to update partner' });
    }
});


// 新しいパートナーを追加
router.post('/partners', authenticateToken, async (req, res) => {
    const { name, type, address, phone, contact_person } = req.body;
    const userId = req.user.userId;

    try {
        // 既存のパートナー名を確認
        if (type === 'supplier') {
            const existingSupplier = await SuppliresKeiri.findOne({ where: { user_id: userId, supplier_name: name } });
            if (existingSupplier) {
                return res.status(400).json({ success: false, message: 'Supplier name already exists' });
            }
        } else if (type === 'customer') {
            const existingClient = await Client.findOne({ where: { user_id: userId, client_name: name } });
            if (existingClient) {
                return res.status(400).json({ success: false, message: 'Client name already exists' });
            }
        }

        // 最大値を取得し、新しいIDを生成
        let newId = 1;
        if (type === 'supplier') {
            const maxSupplier = await SuppliresKeiri.findOne({
                attributes: [[Sequelize.fn('MAX', Sequelize.col('supplier_id')), 'maxId']],
                where: { user_id: userId }
            });
            newId = (maxSupplier.dataValues.maxId || 0) + 1;
        } else if (type === 'customer') {
            const maxClient = await Client.findOne({
                attributes: [[Sequelize.fn('MAX', Sequelize.col('client_id')), 'maxId']],
                where: { user_id: userId }
            });
            newId = (maxClient.dataValues.maxId || 0) + 1;
        }

        // 新しいパートナーを作成
        if (type === 'customer') {
            await Client.create({
                client_id: newId,
                client_name: name,
                client_address: address,
                client_phone: phone,
                client_contact_person: contact_person,
                user_id: userId
            });
        } else if (type === 'supplier') {
            await SuppliresKeiri.create({
                supplier_id: newId,
                supplier_name: name,
                supplier_address: address,
                supplier_phone: phone,
                supplier_contact_person: contact_person,
                user_id: userId
            });
        } else {
            return res.status(400).json({ success: false, message: 'Invalid partner type' });
        }
        res.json({ success: true, message: 'Partner added successfully' });
    } catch (error) {
        console.error('Error adding partner:', error);
        res.status(500).json({ success: false, message: 'An error occurred while adding the partner' });
    }
});

// パートナー情報の削除
router.delete('/partners/:type/:id', authenticateToken, async (req, res) => {
    const { type, id } = req.params;
    try {
        if (type === 'client') {
            await Client.destroy({ where: { id } });
        } else if (type === 'supplier') {
            await SuppliresKeiri.destroy({ where: { id } });
        } else {
            return res.status(400).json({ success: false, message: 'Invalid type' });
        }
        res.json({ success: true, message: 'Partner deleted successfully' });
    } catch (error) {
        console.error('Error deleting partner:', error);
        res.status(500).json({ success: false, message: 'Failed to delete partner' });
    }
});


// module.exports = router;


//keirikun final


//PosMenu
router.get('/pos/getmenu', async (req, res) => {
  try {
  const supplireget = await PosMenu.findAll({
  });
  res.json(supplireget)
} catch (err) {
  res.json(err)
  console.log(err)
}
});

//
// app.get('/chat/history/:userId', async (req, res) => {
//     try {
//         const userId = req.params.userId;
//
//         const messages = await Message.findAll({
//             where: {
//                 [Op.or]: [
//                     { sender_id: userId },
//                     { receiver_id: userId }
//                 ]
//             },
//             order: [['timestamp', 'ASC']]
//         });
//
//         res.json(messages);
//     } catch (err) {
//         console.error('Error fetching chat history:', err);
//         res.status(500).json({ error: 'Failed to fetch chat history' });
//     }
// });


//order App

const OrdersUser = require('../schema/orders/user')
const OrdersMenu = require('../schema/orders/menu')
const OrdersCategory = require('../schema/orders/category')
const OrdersOption = require('../schema/orders/option')
const Orders = require('../schema/orders/orders');
const OrderItems = require('../schema/orders/order_items');

router.get('/orders/getBasedata', async (req, res) => {
  try {
    const userId = req.query.user_id; // クエリパラメータからuser_idを取得
    console.log(userId)

    // Category, Menu, Option のデータをそれぞれ取得
    const categories = await OrdersCategory.findAll({
      where: { user_id: userId }
    });

    const menus = await OrdersMenu.findAll({
      where: { user_id: userId }
    });

    const options = await OrdersOption.findAll({
      where: { user_id: userId }
    });

    // 取得したデータをまとめてJSONで返す
    const getData = {
      categories: categories,
      menus: menus,
      options: options
    };

    res.json(getData); // 結果をJSONとして返す
  } catch (err) {
    res.json({ error: err.message }); // エラー時のレスポンス
    console.log(err);
  }
});




router.get('/orders/getmenu', async (req, res) => {
  try {
    const userId = req.query.user_id; // クエリパラメータからuser_idを取得
    const getData = await OrdersMenu.findAll({
      where: {
        user_id: userId // user_idを条件にデータを取得
      }
    });
    res.json(getData);
  } catch (err) {
    res.json(err);
    console.log(err);
  }
});

router.get('/orders/getuser', async (req, res) => {
  try {
    const userId = req.query.email; // クエリパラメータからuser_idを取得
    const getData = await OrdersUser.findAll({
      where: {
        email: userId // user_idを条件にデータを取得（この場合、OrdersUserの主キーと一致することが想定されます）
      }
    });
    res.json(getData);
  } catch (err) {
    res.json(err);
    console.log(err);
  }
});

router.get('/orders/getcategory', async (req, res) => {
  try {
    const userId = req.query.user_id; // クエリパラメータからuser_idを取得
    console.log('id is' + userId)
    const getData = await OrdersCategory.findAll({
      where: {
        user_id: userId // user_idを条件にデータを取得
      }
    });
    res.json(getData);
  } catch (err) {
    console.log(err)
    res.json(err);
    console.log(err);
  }
});

router.get('/orders/getoption', async (req, res) => {
  try {
    const userId = req.query.user_id; // クエリパラメータからuser_idを取得
    const getData = await OrdersOption.findAll({
      where: {
        user_id: userId // user_idを条件にデータを取得
      }
    });
    res.json(getData);
  } catch (err) {
    res.json(err);
    console.log(err);
  }
});

const processOrder = async (order) => {
    // console.log(`Processing Order ID: ${order.id}`);

    const categorizedItems = {};

    // OrderItemsをループ
    for (let item of order.OrderItems) {
        const menuId = item.dataValues.menu_id;

        // menu_id から Menu を取得して category_id と menu_name_pt を取得
        const menu = await OrdersMenu.findOne({
            where: { id: menuId },
            attributes: ['category_id', 'menu_name_pt']  // category_id と menu_name_pt を取得
        });

        if (menu) {
            const categoryId = menu.dataValues.category_id;
            const menuNamePt = menu.dataValues.menu_name_pt;

            // category_id から Category を取得して printer_ip を取得
            const category = await OrdersCategory.findOne({
                where: { id: categoryId }
            });

            if (category) {
                const printerIp = category.dataValues.printer_ip;

                // IPごとにアイテムを分類
                if (!categorizedItems[printerIp]) {
                    categorizedItems[printerIp] = [];
                }

                // item.dataValues に menu_name_pt を追加して分類
                categorizedItems[printerIp].push({
                    ...item.dataValues,
                    menu_name_pt: menuNamePt
                });
            } else {
                console.error(`Category not found for category_id: ${categoryId}`);
            }
        } else {
            console.error(`Menu not found for menu_id: ${menuId}`);
        }
    }

    // // 各プリンターIPに対応するアイテムを表示
    // for (let printerIp in categorizedItems) {
    //     console.log(`Printer IP: ${printerIp}`);
    //     console.log(`Items:`, categorizedItems[printerIp]);
    // }

    return categorizedItems;
};

// エンドポイント
router.get('/orders/test2', async (req, res) => {
    try {
        console.log('tests');

        const unprintedOrders = await Orders.findAll({
            where: { coupon_printed: false },
            include: [{ model: OrderItems }]
        });

        const results = [];

        for (let order of unprintedOrders) {
            const categorizedItems = await processOrder(order.dataValues);
            results.push({
                order_id: order.dataValues.id,
                table_no: order.dataValues.table_no,
                order_name: order.dataValues.order_name,
                categorizedItems
            });

            // sendToPrinters関数にオーダー情報を送信
            await sendToPrinters(
                order.dataValues.id,
                order.dataValues.table_no,
                order.dataValues.order_name,
                categorizedItems
            );
        }

        res.json(results);

    } catch (err) {
        res.json(err);
        console.log(err);
    }
});



router.post('/orders/confirm', async (req, res) => {
    const { order_name, user_id, table_no, items } = req.body;
    try {
        // 既存の注文を確認
        let existingOrder = await Orders.findOne({
            where: {
                user_id: user_id,
                table_no: table_no,
                order_name: order_name,
                order_status: 'pending'
            },
            order: [['id', 'DESC']]
        });
        if (existingOrder) {
            // 既存の注文が存在する場合、その注文IDにアイテムを追加
            const existingOrderId = existingOrder.id;

            const orderItems = items.map(item => ({
                order_id: existingOrderId,
                menu_id: item.id,
                quantity: item.quantity,
                options: JSON.stringify(item.options),
                item_price: item.amount,
                total_price: item.amount * item.quantity,
                created_at: new Date(),
                updated_at: new Date()
            }));
            await OrderItems.bulkCreate(orderItems);
            // 総額を更新
            const additionalAmount = items.reduce((acc, item) => acc + (item.amount * item.quantity), 0);
            existingOrder.total_amount = parseFloat(existingOrder.total_amount) + parseFloat(additionalAmount);
            existingOrder.updated_at = new Date();

            // データベースに保存
            await existingOrder.save();

            res.status(200).json({ message: 'Order updated successfully' });
        } else {
            // 新規注文を作成
            const newOrder = await Orders.create({
                user_id: user_id,
                table_no: table_no,
                order_name: order_name,
                total_amount: items.reduce((acc, item) => acc + item.amount * item.quantity, 0),
                order_status: 'pending',
                created_at: new Date(),
                updated_at: new Date()
            });

            // 各アイテムを OrderItems テーブルに追加
            const orderItems = items.map(item => ({
                order_id: newOrder.id,
                menu_id: item.id,
                quantity: item.quantity,
                options: JSON.stringify(item.options),
                item_price: item.amount,
                total_price: item.amount * item.quantity,
                created_at: new Date(),
                updated_at: new Date()
            }));

            await OrderItems.bulkCreate(orderItems);

            res.status(200).json({ message: 'Order confirmed successfully' });
        }
        //プリンターにデータを転送
        const printerDt = await  groupItemsByPrinter(items)
        sendToPrinters(printerDt)

    } catch (error) {
        console.error('Error confirming order:', error);
        res.status(500).json({ error: 'Failed to confirm order' });
    }
});

const escpos = require('escpos');
escpos.Network = require('escpos-network');

async function sendToPrinters(id, tableNo, orderName, contents) {

    console.log('print Start');
    console.log(id);
    console.log(tableNo);
    console.log(orderName);
    console.log(contents);

    // const escpos = require('escpos');
    // escpos.Network = require('escpos-network');

    // contents から printerIp を取得し、ループで処理
    for (let printerIp in contents) {
       console.log(printerIp)
        const items = contents[printerIp];

        // ネットワークプリンターを設定
        const device = new escpos.Network(printerIp);
        const printer = new escpos.Printer(device);

        // プリンター接続
    //     device.open(function (error) {
    //         if (error) {
    //             console.error(`Error connecting to printer ${printerIp}:`, error);
    //             return;
    //         }
    //
    //         // 日付を取得
    //         const currentDate = new Date().toLocaleString();
    //
    //         // クーポンのヘッダー
    //         printer
    //             .align('CT')
    //             .text(`オーダーテーブル: ${tableNo}`)
    //             .text(`オーダー名: ${orderName}`)
    //             .text(`日付: ${currentDate}`)
    //             .newline();
    //
    //         // オーダーリストをプリント
    //         items.forEach(item => {
    //             printer
    //                 .align('LT')
    //                 .text(`- ${item.menu_name_pt}  x${item.quantity}`)
    //                 .newline();
    //         });
    //
    //         // クーポンのフッター
    //         printer
    //             .newline()
    //             .text('Thank you for your order!')
    //             .cut();
    //
    //         // プリント完了
    //         printer.close();
    //     });
    }
}





function groupItemsByPrinter(items) {
    const groupedItems = {};

    items.forEach(item => {
        const printer = item.printer;

        if (!groupedItems[printer]) {
            groupedItems[printer] = [];
        }

        groupedItems[printer].push({
            name: item.name,
            quantity: item.quantity
        });
    });

    return groupedItems;
}


// オーダー履歴を取得するエンドポイント
router.get('/orders/history', async (req, res) => {
    try {
        const orders = await Orders.findAll({
            where: { order_status: 'confirmed' }, // もしくは適切な条件で絞り込む
            attributes: ['id', 'order_name']
        });
        res.json(orders);
    } catch (error) {
        console.error('Error fetching order history:', error);
        res.status(500).json({ error: 'Failed to fetch order history' });
    }
});

// 特定のオーダー詳細を取得するエンドポイント
router.get('/orders/:id', async (req, res) => {
    const orderId = req.params.id;
    try {
        const order = await Orders.findOne({
            where: { id: orderId },
            include: [{ model: OrderItems }] // OrderItemsを含めて取得
        });

        if (!order) {
            return res.status(404).json({ error: 'Order not found' });
        }

        res.json(order);
    } catch (error) {
        console.error('Error fetching order details:', error);
        res.status(500).json({ error: 'Failed to fetch order details' });
    }
});

// ルートの設定例
router.post('/orders/getOrder', async (req, res) => {
    const { user_id, table_no, order_name } = req.body;

    try {
        // データベースからオーダー情報を取得
        const order = await Orders.findOne({
            where: {
                user_id: user_id,
                table_no: table_no,
                order_name: order_name,
                order_status: 'pending', // 'pending'のオーダーを取得
            },
            include: [{ model: OrderItems }] // 関連するOrderItemsも一緒に取得
        });

        console.log(req.body)
        console.log(order)

        if (order) {
            res.status(200).json(order);
        } else {
            res.status(404).json({ message: 'Order not found' });
        }
    } catch (error) {
        console.error('Error fetching order:', error);
        res.status(500).json({ error: 'Failed to fetch order' });
    }
});




// const device  = new escpos.Network('192.168.0.100'); // プリンターのIPアドレス
// const printer = new escpos.Printer(device);
//
// device.open(function(){
//   printer
//     .text('Hello World')
//     .cut()
//     .close();
// });


router.post('/orders/pending', async (req, res) => {
    const { client_id } = req.body;
    try {
        const orders = await Orders.findAll({
            where: {
                user_id: client_id,
                order_status: 'pending'
            },
            include: [{ model: OrderItems }] // OrderItemsを含めて取得

        });
        res.json(orders);
    } catch (error) {
        console.error('Error fetching orders:', error);
        res.status(500).json({ error: 'Failed to fetch orders' });
    }
});

router.post('/orders/updatePayment', async (req, res) => {
    const { order_id, payment_method, order_status } = req.body;

    try {
        const order = await Orders.findByPk(order_id);
        if (order) {
            order.payment_method = payment_method;
            order.order_status = order_status;
            await order.save();
            res.status(200).json({ message: 'Order updated successfully' });
        } else {
            res.status(404).json({ error: 'Order not found' });
        }
    } catch (error) {
        console.error('Error updating order:', error);
        res.status(500).json({ error: 'Failed to update order' });
    }
});

router.post('/orders/testete', async (req, res) => {
    console.log('ok')

});



console.log('new version')
router.get('/orders/unprinted', async (req, res) => {
  console.log('kokonihairanai')
    try {
      // console.log('printStart')
      //   const unprintedOrders = await Orders.findAll({
      //       where: { coupon_printed: false },
      //       include: [{
      //           model: OrderItems,
      //           as: 'orderItems'
      //       }]
      //   });
      //   console.log(unprintedOrders)
      //   res.json(unprintedOrders);
    } catch (error) {
      console.log(error)
        res.status(500).json({ error: 'データの取得に失敗しました。' });
    }
});


//bae
